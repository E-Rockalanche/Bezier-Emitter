/*
assignment1.cpp
Eric Roberts
*/

#define _USE_MATH_DEFINES

#include <math.h>
#include <string>
#include <iostream>
#include <iomanip>

#include <GL/gl.h>
#include <GL/glu.h>
#include "GL/glut.h"

#include "light.hpp"
#include "loaders.hpp"
#include "stb_image.h"
#include "vec3.hpp"
#include "matrix.hpp"
#include "screen.hpp"

Object object;
unsigned int* textures;
int last_mpos[2];
int cur_mpos[2];
bool arcball_on = false;
float model_rotation_matrix[16];
float camera_pos[3] = { 0.0, 0.0, 35.0 };

GLfloat white[4] = { 1.0, 1.0, 1.0, 1.0 };

Light lights[4] {
	Light(white, white, (const GLfloat[]){ 0.5, 0.5, 0.5, 1.0 }, (const GLfloat[]){ 0.0, 6.0, 300.0 }, true),
	Light(white, (const GLfloat[]){ 1.0, 0.2, 0.2, 1.0 }, (const GLfloat[]){ 0.5, 0.1, 0.1, 1.0 }, (const GLfloat[]){ -30.0, 6.0, 0.0, 0.0 }, false),
	Light(white, (const GLfloat[]){ 0.2, 1.0, 0.2, 1.0 }, (const GLfloat[]){ 0.1, 0.5, 0.1, 1.0 }, (const GLfloat[]){ 0.0, 30.0, 0.0, 0.0 }, false),
	Light(white, (const GLfloat[]){ 0.2, 0.2, 1.0, 1.0 }, (const GLfloat[]){ 0.1, 0.1, 0.5, 1.0 }, (const GLfloat[]){ 30.0, 6.0, 0.0, 0.0 }, false)
};

void mouseAction(int button, int state, int x, int y) {
	switch(button) {
		case GLUT_LEFT_BUTTON:
			if (state == GLUT_DOWN) {
				arcball_on = true;
				last_mpos[0] = cur_mpos[0] = x;
				last_mpos[1] = cur_mpos[1] = y;
			} else {
				arcball_on = false;
			}
			break;
			
		case 3: // mouse wheel up
			camera_pos[2] -= 1;
			break;
			
		case 4: // mouse wheel down
			camera_pos[2] += 1;
			break;
			
		default:
			arcball_on = false;
			break;
	}
}

void mouseMotion(int x, int y) {
	if (arcball_on) {
		cur_mpos[0] = x;
		cur_mpos[1] = y;
	}
}

void keyboardInput(unsigned char key, int x, int y) {
	if (key >= '1' && key <= '4') {
		int light = key - '1';
		lights[light].enabled = !lights[light].enabled;
	}
}

void specialKeyboardInput(int key, int x, int y) {
	switch(key) {
		case GLUT_KEY_UP:
			camera_pos[1] += 1;
			break;
			
		case GLUT_KEY_DOWN:
			camera_pos[1] -= 1;
			break;
			
		case GLUT_KEY_RIGHT:
			camera_pos[0] += 1;
			break;
			
		case GLUT_KEY_LEFT:
			camera_pos[0] -= 1;
			break;
	}
}

void checkError(const char* message) {
	GLenum error_enum = glGetError();
	if (GL_NO_ERROR != error_enum) {
		std::cout << "openGL error: " << error_enum << ", " << message << '\n';
		exit(1);
	}
}

unsigned int loadImage(std::string file, std::string path) {
	std::string filename = path + file;
	int width, height, nrChannels;
	unsigned char* data = stbi_load(filename.c_str(), &width, &height, &nrChannels, 4);
	
	if (data == NULL) {
		std::cout << "failed to load image " << filename << '\n';
		exit(1);
	}
	
	// create openGL texture
	unsigned int texture;
	glGenTextures(1, &texture);
	
	checkError("after gen textures");
	
	// bind texture for future operations
	glBindTexture(GL_TEXTURE_2D, texture);
	
	// give image to openGL
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	
	GLenum error_enum = glGetError();
	if (GL_NO_ERROR != error_enum) {
		std::cout << "an openGL error occurred while loading " << filename << '\n';
		exit(1);
	}
	
	glBindTexture(GL_TEXTURE_2D, 0);
	
	stbi_image_free(data);
	return texture;
}

void initializeScene()
{
	// glShadeModel( GL_FLAT );
	glShadeModel( GL_SMOOTH );

  	glEnable(GL_DEPTH_TEST);
  	glEnable(GL_NORMALIZE);
  	
  	for(int i = 0; i < 4; i++) {
  		for(int j = 0; j < 4; j++) {
  			model_rotation_matrix[i*4 + j] = (i == j && i < 4) ? 1.0 : 0.0;
  		}
  	}
}

// GLUT callback to handle rendering the scene
void renderScene(void)
{
	//rotation
	static Matrix rotation_matrix;
	
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glEnable(GL_LIGHTING);
	for(int i = 0; i < 4; i++) {
		int light = GL_LIGHT0 + i;
		if (lights[i].enabled) {
			glEnable(light);
			glLightfv(light, GL_SPECULAR, lights[i].specular);
			glLightfv(light, GL_DIFFUSE, lights[i].diffuse);
			glLightfv(light, GL_AMBIENT, lights[i].ambient);
			glLightfv(light, GL_POSITION, lights[i].position);
		} else {
			glDisable(light);
		}
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(45.0f,   // FOV y
					1.0f, 	// Aspect ratio (width/height)
					0.1f, 	// Near distance
					1000.0f);// Far distance

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
	lights[0].position[1] = object.origin[1];

	gluLookAt( camera_pos[0], camera_pos[1], camera_pos[2],    // Eye position
				camera_pos[0], camera_pos[1], camera_pos[2]-1, 	  // Lookat position
  				0.0f, 1.0f, 0.0f );	  // Up vector

	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	glPushMatrix();
	{
		glTranslatef(object.origin[0], object.origin[1], object.origin[2]);
	
		// calculate arcball rotation
		if (arcball_on && ((last_mpos[0] != cur_mpos[0]) || (last_mpos[1] != cur_mpos[1]))) {
			vec3 m1 = getArcballVector(last_mpos[0], last_mpos[1]);
			vec3 m2 = getArcballVector(cur_mpos[0], cur_mpos[1]);
			float angle = 2 * std::acos(std::min(1.0f, dot(m1, m2)));
			vec3 axis = normalize(cross(m1, m2));
			
			Matrix new_rotation = calcRotationMatrix(angle, axis);
			rotation_matrix = rotation_matrix * new_rotation;
			
			for(int i = 0; i < 2; i++) {
				last_mpos[i] = cur_mpos[i];
			}
		}
		
		// glRotatef(rotation_angle * 180 / M_PI, rotation_axis.x, rotation_axis.y, rotation_axis.z);
		glMultMatrixf(rotation_matrix.data);
		
		glTranslatef(-object.origin[0], -object.origin[1], -object.origin[2]);

		glEnableClientState(GL_NORMAL_ARRAY);
		glNormalPointer(GL_FLOAT, 0, object.normals.data());

		glEnableClientState(GL_VERTEX_ARRAY);
		glVertexPointer(3, GL_FLOAT, 0, object.vertices.data());
		
		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
		glTexCoordPointer(2, GL_FLOAT, 0, object.tex_coords.data());
		
		for(auto it = object.polygon_groups.begin(); it != object.polygon_groups.end(); it++) {
			const PolygonGroup& group = it->second;
			
			Material mat = object.materials[group.material];
			
			/*
			glEnable(GL_COLOR_MATERIAL);
			glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
			glMaterialfv(GL_FRONT, GL_SPECULAR, mat.specular_colour);
			glMateriali(GL_FRONT, GL_SHININESS, mat.specular_weight);
			*/
			
			if (group.vertex_indices.size() > 0) {
				unsigned int texture = mat.texture_handle;
				glBindTexture(GL_TEXTURE_2D, texture);
				glDrawElements(GL_TRIANGLES, group.vertex_indices.size(), GL_UNSIGNED_INT, group.vertex_indices.data());
			}
		}
	}
	glPopMatrix();
	glutSwapBuffers();
}

int main(int argc, char* argv[]) {
	std::string obj_full_path;
	for(int i = 0; i < argc; i++) {
		if (std::string("-m") == argv[i]) {
			if (obj_full_path.size() > 0) {
				std::cout << "object filename already provided\n";
				return 1;
			} else if (++i < argc) {
				obj_full_path = argv[i];
			} else {
				std::cout << "no object filename after -m flag\n";
				return 1;
			}
		}
	}
	if (obj_full_path.size() == 0) {
		std::cout << "no object filename given\n";
		return 1;
	}
	
	std::string path;
	std::string obj_filename;
	for(int i = 0; i < (int)obj_full_path.size(); i++) {
		char c = obj_full_path[i];
		obj_filename += c;
		if (c == '/' || c == '\\') {
			path += obj_filename;
			obj_filename = "";
		}
	}
	
	bool success = loadObject(obj_filename, path, object);
	if (!success) {
		std::cout << "could not load object\n";
		return 1;
	}
	
	camera_pos[1] = object.origin[1];
	
	glutInit(&argc, argv);

	glutInitDisplayMode(GLUT_DEPTH|GLUT_SINGLE|GLUT_RGB);

	glutInitWindowPosition(100,100);
	glutInitWindowSize( SCREENWIDTH, SCREENHEIGHT );
	glutCreateWindow("Assignment 1");

	glViewport( 0, 0, SCREENWIDTH, SCREENHEIGHT );
	
	glEnable(GL_BLEND);
	glEnable(GL_TEXTURE_2D);
	
	for(auto it = object.materials.begin(); it != object.materials.end(); it++) {
		Material& material = it->second;
		std::string filename = material.diffuse_tex_file;
		if (filename.size() == 0) {
			material.texture_handle = 0;
		} else {
			material.texture_handle = loadImage(filename, path);
		}
	}

	glutDisplayFunc(renderScene);
	glutIdleFunc(renderScene);
	glutMouseFunc(mouseAction);
	glutMotionFunc(mouseMotion);
	glutKeyboardFunc(keyboardInput);
	glutSpecialFunc(specialKeyboardInput);

	initializeScene();

	//  GLUT main loop
	glutMainLoop();
	
	delete[] textures;

	return(0);
}

